//lighting_pass.comp
#version 430

// 输入G-Buffer纹理
layout(binding = 0) uniform sampler2D gPosition;
layout(binding = 1) uniform sampler2D gNormal;
layout(binding = 2) uniform sampler2D gCurvatureMax;  // κ1
layout(binding = 3) uniform sampler2D gCurvatureMin;  // κ2
layout(binding = 4) uniform sampler2D gCurvatureDir;  // 主曲率方向

// 传输函数纹理
layout(binding = 5) uniform sampler1D curvatureColorMap;  // 曲率颜色映射
layout(binding = 6) uniform sampler2D ridgeValleyMap;     // 脊线和谷线检测
//layout(binding = 7) uniform sampler2D noiseTexture;       // 流场噪声纹理

// 输出图像
layout(rgba32f, binding = 7) uniform image2D outputImage;

// 参数
uniform vec3 lightPos;
uniform vec3 viewPos;
uniform float flowSpeed;
uniform float flowScale;
uniform float time;
uniform bool showRidges;
uniform bool showValleys;
uniform float accessibilityStrength;
uniform vec2 screenSize;
uniform vec3 lightColor;


layout(local_size_x = 8, local_size_y = 8, local_size_z = 1) in;

// 修改方向导数的计算
float computeDirectionalCurvature(vec2 texCoord, vec2 dir) {
    vec2 h = 1.0 / textureSize(gCurvatureMax, 0);
    
    // 在主曲率方向上采样曲率
    float k_forward = texture(gCurvatureMax, texCoord + dir * h).r;
    float k_center = texture(gCurvatureMax, texCoord).r;
    float k_backward = texture(gCurvatureMax, texCoord - dir * h).r;
    
    // 计算二阶中心差分
    return (k_forward - 2.0 * k_center + k_backward) / (length(h) * length(h));
}
// 计算平均曲率
float computeMeanCurvature(vec2 texCoord) {
    float k1 = texture(gCurvatureMax, texCoord).r;
    float k2 = texture(gCurvatureMin, texCoord).r;
    return (k1 + k2) * 0.5;
}

// 计算高斯曲率
float computeGaussianCurvature(vec2 texCoord) {
    float k1 = texture(gCurvatureMax, texCoord).r;
    float k2 = texture(gCurvatureMin, texCoord).r;
    return k1 * k2;
}

// 可访问性着色
float computeAccessibility(vec2 texCoord) {
    float k1 = texture(gCurvatureMax, texCoord).r;
    float k2 = texture(gCurvatureMin, texCoord).r;
    
    float meanCurv = (k1 + k2) * 0.5;
    return 1.0 - accessibilityStrength * clamp(-meanCurv, 0.0, 1.0);
}

// Ridge和Valley检测
vec4 computeRidgeValley(vec2 texCoord) {
    float k1 = texture(gCurvatureMax, texCoord).r;
    float k2 = texture(gCurvatureMin, texCoord).r;
    vec2 maxCurvDir = texture(gCurvatureDir, texCoord).xy;
    
    // 放宽阈值
    const float DERIV_THRESHOLD = 0.1;     // 增大阈值
    const float CURVATURE_RATIO = 1.2;     // 降低比值要求
    const float MIN_CURVATURE = 0.001;     // 降低最小曲率要求
    
    // 计算主曲率方向上的二阶导数
    float directionalCurv = computeDirectionalCurvature(texCoord, maxCurvDir);
    
    vec4 feature = vec4(0.0);
    
    // Ridge检测：
    if (k1 > MIN_CURVATURE &&                          // 曲率要足够大
        k1 > CURVATURE_RATIO * max(abs(k2), 0.001) && // 显著大于k2
        (directionalCurv < 0.0)) {                  // 二阶导数为负（局部最大）
        
        // 检查是否是局部最大值，使用更小的邻域
        float h = 0.5 / max(screenSize.x, screenSize.y);
        float k1_left = texture(gCurvatureMax, texCoord - vec2(h, 0.0)).r;
        float k1_right = texture(gCurvatureMax, texCoord + vec2(h, 0.0)).r;
        float k1_up = texture(gCurvatureMax, texCoord + vec2(0.0, h)).r;
        float k1_down = texture(gCurvatureMax, texCoord - vec2(0.0, h)).r;
        
        if (k1 >= k1_left && k1 >= k1_right && k1 >= k1_up && k1 >= k1_down) {
            feature.r = 1.0;
            feature.a = 0.8;  // 降低alpha以减少视觉上的强度
        }
    }
    
    // Valley检测
    vec2 minCurvDir = vec2(-maxCurvDir.y, maxCurvDir.x); // 垂直于最大曲率方向
    float directionalCurv2 = computeDirectionalCurvature(texCoord, minCurvDir);
    
    if (k2 < -MIN_CURVATURE &&                         // 曲率要足够小（负）
        abs(k2) > CURVATURE_RATIO * max(abs(k1), 0.001) && 
        (directionalCurv2 > 0.0)) {                 // 二阶导数为正（局部最小）
        
        float h = 0.5 / max(screenSize.x, screenSize.y);
        float k2_left = texture(gCurvatureMin, texCoord - vec2(h, 0.0)).r;
        float k2_right = texture(gCurvatureMin, texCoord + vec2(h, 0.0)).r;
        float k2_up = texture(gCurvatureMin, texCoord + vec2(0.0, h)).r;
        float k2_down = texture(gCurvatureMin, texCoord - vec2(0.0, h)).r;
        
        if (k2 <= k2_left && k2 <= k2_right && k2 <= k2_up && k2 <= k2_down) {
            feature.g = 1.0;
            feature.a = 0.8;
        }
    }
    
    if (!showRidges) feature.r = 0.0;
    if (!showValleys) feature.g = 0.0;
    
    return feature;
}
vec3 computeCurvatureFlow(vec2 texCoord) {
    // 获取主曲率方向
    vec2 flowDir = texture(gCurvatureDir, texCoord).xy;
    
    // 计算流动坐标
    vec2 flowCoord = texCoord * flowScale;
    flowCoord += flowDir * time * flowSpeed;
    
    // 使用ridgeValleyMap作为噪声源（因为它已经是2D纹理）
    float noise1 = texture(ridgeValleyMap, flowCoord).r;
    float noise2 = texture(ridgeValleyMap, flowCoord * 2.0 + vec2(time * 0.5)).r;
    
    return vec3(mix(noise1, noise2, 0.5));
}

void main() {
    ivec2 pixel_coords = ivec2(gl_GlobalInvocationID.xy);
    
    // 检查是否在图像范围内
    ivec2 dims = imageSize(outputImage);
    if (pixel_coords.x >= dims.x || pixel_coords.y >= dims.y) {
        return;
    }
    
    // 计算纹理坐标
    vec2 texCoord = vec2(pixel_coords) / vec2(dims);
    
    // 获取G-buffer数据
    vec3 pos = texture(gPosition, texCoord).xyz;
    vec3 normal = normalize(texture(gNormal, texCoord).xyz);
    

/*
    // 可视化法线调试
    vec3 normalColor = (normal + 1.0) * 0.5;  // 将法线映射到 [0,1] 范围
    imageStore(outputImage, pixel_coords, vec4(normalColor, 1.0));
    return;
*/
    // 跳过背景像素
//    if (length(normal) < 0.1) {
    if (length(texture(gNormal, texCoord).xyz) < 0.1) {
        imageStore(outputImage, pixel_coords, vec4(1.0, 1.0, 1.0, 1.0));  // 白色背景
        return;
    }
    // 计算基本光照向量
    vec3 lightDir = normalize(lightPos - pos);
    vec3 viewDir = normalize(viewPos - pos);
    vec3 halfDir = normalize(lightDir + viewDir);
    float shininess = 32.0;
    // 计算光照分量
    float diff = max(dot(normal, lightDir), 0.0);
    float spec = pow(max(dot(normal, halfDir), 0.0), shininess);
    float Ka=0.1;
    float Kd=0.7;
    float Ks=0.2;
    // 计算最终颜色
    vec3 ambient = Ka * lightColor;
    vec3 diffuse = Kd * diff * lightColor;
    vec3 specular = Ks * spec * lightColor;

    
    // 合并所有光照分量
    vec3 baseColor = ambient + diffuse + specular;
    
    // 2. 曲率着色
    float meanCurv = computeMeanCurvature(texCoord);
    vec3 curvatureColor = texture(curvatureColorMap, meanCurv * 0.5 + 0.5).rgb;
    
    // 3. 可访问性着色
    float accessibility = computeAccessibility(texCoord);
    
    // 4. 脊线和谷线
    vec4 ridgeValley = computeRidgeValley(texCoord);
    // 5. 流场可视化
    vec3 flow = computeCurvatureFlow(texCoord);
    
    // 合并所有效果
    vec3 finalColor = baseColor;
    
    // 应用可访问性
    finalColor *= accessibility;
    
    // 混合曲率颜色
    finalColor = mix(finalColor, curvatureColor, 0.3);
    
    // 添加脊线和谷线
    finalColor = mix(finalColor, ridgeValley.rgb, ridgeValley.a*0.5);
    
    // 添加流场效果
    finalColor = mix(finalColor, flow, 0.3);
    
    // 建议尝试不同的混合比例
    
    // 存储结果
    imageStore(outputImage, pixel_coords, vec4(finalColor, 1.0));
}